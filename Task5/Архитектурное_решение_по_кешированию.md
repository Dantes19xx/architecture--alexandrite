1. Анализ
Что можно закешировать:
 - Shop API (Список товаров (если не часто обновляется), часто запрашиваемые 3D-модели или их метаинформацию.)
 - 3d files storage (Мелкие часто используемые 3D-файлы (например, превью, метаданные), 
   Результаты расчётов по файлам (если они ресурсоёмкие)
   )
 - MES API / CRM API (Часто запрашиваемые статусы заказов, пользовательские данные, не меняющиеся часто)

2. Мотивация
 - Снижение нагрузки на базу данных и хранилища(Кеширование часто запрашиваемых данных (списка товаров, превью 3D моделей) позволяет отвечать из памяти, разгружая БД и ускоряя ответы)
 - Ускорение времени отклика в системах, где есть кеш, а так же в других системах, за счет освобождения ресурсов 
 - Сглаживание всплесков трафика (Кеширование популярных данных позволяет обслуживать всплески с минимальной нагрузкой на backend)
 - Снижение стоимости облачных операций (Так как кешируются часто используемые 3d файлы, обращений в s3 будет меньше)
 - Сервисы, куда стоит подключить кеширование, описано в предыдущем пункте.

3. Предполагаемое решение

[Предполагаемое решение](Предлагаемое_решение.drawio)

Выберу серверное кеширование, потому что в этом случае контроль будет на стороне backend: 
можно централизованно управлять стратегией кеша, TTL, инвалидацией.
В отличие от клиентского кеша, не кэшируются чувствительные данные на фронте.
А так же можно адаптировать стратегию кеширования под нагрузку, типы запросов, использовать Redis.

- Shop API — кеширование списка товаров
Паттерн: Cache-Aside
Почему он подходит: Данные читаются чаще, чем изменяются. Позволяет вручную управлять сроком жизни и инвалидацией.
Почему не другие:
Write-Through создаёт избыточную нагрузку на кеш при каждой записи, не имеет смысла при редких обновлениях.
Refresh-Ahead сложнее реализовать, оправдан при строго фиксированных интервалах обновления, 
но не для пользовательских запросов.

- Кеширование результатов расчёта в MES API, 3d storage
Паттерн: Cache-Aside
Расчёт может быть дорогим, но данные могут меняться — важно контролировать их валидность вручную.

4. Стратегия инвалидации кеша

Инвалидация по ключу (программная)
Почему она подходит:
В системе есть явный момент, когда заказ изменяется (например, изменение статуса).
Можно точно определить, какой ключ в Redis нужно удалить.
Обеспечивает актуальность данных при минимальной задержке.

| Стратегия                                     | Описание                                                    | Преимущества                                                 | Недостатки                                        
| --------------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- 
| **По времени (TTL)**                          | Кеш удаляется через фиксированный промежуток времени        | Простота реализации, нет необходимости отслеживать изменения | Возможны устаревшие данные, нет гарантии свежести 
| **По ключу**                                  | Удаление конкретного ключа при изменении данных             | Актуальные данные, высокая точность                          | Требует явного контроля на уровне кода            
| **Программная логика**                        | Удаление или обновление кеша при выполнении бизнес-операции | Полный контроль над кешем, гибкость                          | Сложность реализации, риск ошибок                 
| **Автоматическое обновление (Refresh-Ahead)** | Кеш обновляется заранее по таймеру                          | Предотвращает кеш-мисс, данные всегда «свежие»               | Сложная реализация, ресурсоёмко                   
| **Write-through**                             | Данные сначала пишутся в кеш, потом в БД                    | Согласованность данных                                       | Нагрузка на кеш, задержки при записи              
